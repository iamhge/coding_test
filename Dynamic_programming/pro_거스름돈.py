# 거스름돈
'''
<풀이 방법>
  다이나믹 프로그래밍
    - dp로 풀어야할 것같긴 했는데, 방법을 모르겠어서 아래 링크 참고
    - an = sum(an-coin) 이라고 생각했으나 실제 로직과는 차이가 있다. 
      각 coin이 영향끼치는 것을 생각해야한다.
      [1, 2, 5]를 예로 들면, 
        1) 1원만 포함된 경우
        2) 1에서 2원이 포함된 경우
        3) 2에서 5원이 포함된 경우를 순차적으로 생각해야한다.
<참고>
  [Python] 프로그래머스 - 거스름돈 (연습문제/DP)
  : https://velog.io/@younge/Python-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9CDP
ex) [1, 2, 5]
n = 1 -> 1(1)
n = 2 -> 2(11, 2)
n = 3 -> 2(111, 12)
n = 4 -> 3(1111, 112, 22)
n = 5 -> 4(11111, 1112, 122, 5)
n = 6 -> 5(111111, 11112, 1122, 222, 15)
n = 7 -> 6(1111111, 111112, 11122, 1222, 115, 25)
n = 8 -> 7(11111111, 1111112, 111122, 11222, 2222, 1115, 125), 
n = 9 -> 8(111111111, 11111112, 1111122, 111222, 12222, 11115, 1125, 225)
n = 10 -> 9(1111111111, 111111112, 11111122, 1111222, 112222, 22222, 111115, 11125, 1225, 55)

ex) [2, 3]
n = 1 -> 0 
n = 2 -> 1 (2)
n = 3 -> 1 (3)
n = 4 -> 1 (22)
n = 5 -> 1 (23)
n = 6 -> 2 (222, 33)
n = 7 -> 1 (223)
n = 8 -> 2 (2222, 233)
n = 9 -> 2 (2223, 333)
n = 10 -> 2 (22222, 2233)

ex) [3, 5]
n = 3 -> 1 (3)
n = 4 -> 0
n = 5 -> 1 (5)
n = 6 -> 1 (33)
n = 7 -> 0
n = 8 -> 1 (35)
n = 9 -> 1 (333)
n = 10 -> 1 (55)
'''

def solution(n, money):
    dp = [1] + [0]*n
    
    for coin in money:
        for price in range(coin, n+1):
            if price >= coin:
                dp[price] += dp[price-coin]
    
    return dp[n] % 1000000007

# 시간 초과
'''
def solution(n, money):
    dp = [[[i]] if i in money else [] for i in range(n+1)]
    
    for i in range(n+1):
        for m in money:
            if i > m:
                for case in dp[i-m]:
                    tmp = case[:]
                    tmp.append(m)
                    if sorted(tmp) not in dp[i]:
                        dp[i].append(sorted(tmp))

    return len(dp[n]) % 1000000007
'''